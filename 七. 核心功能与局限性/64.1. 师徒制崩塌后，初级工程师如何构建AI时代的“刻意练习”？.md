# 64.1. 师徒制崩塌后，初级工程师如何构建AI时代的“刻意练习”？

> **问题背景**：上一篇我们提到了“初级程序员”的消亡和“师徒制”的崩塌。但这引出了一个巨大的悖论：**如果 AI 把练手的“杂活”都干了，新人去哪里积累那 10,000 小时的经验，从而生长出能够“审核”AI 代码的直觉与品味（Taste）？** 本文将给出一套在 AI 时代生存的**“逆向刻意练习”指南**。

---

## 一、 认知翻转：从“写”代码到“判”代码

在过去，我们的成长路径是：
`写烂代码 -> 被骂/出Bug -> 改代码 -> 慢慢写出好代码`
这是一个**“肌肉记忆”**的养成过程。

在 AI 时代，这个闭环失效了。因为你写的速度永远赶不上 AI，且 AI 一开始写的可能就比你好。
新的成长路径必须转变为：
`阅读高质量代码 -> 建立心理表征 -> 审查 AI 代码 -> 发现细微违和感 -> 修正 AI`
这是一种**“鉴赏家”**的养成过程。你不再需要亲自去烧每一块砖，但你必须一眼就能看出哪块砖烧裂了。

---

## 二、 具体战术：AI 时代的刻意练习方法论

既然“杂活”没了，我们必须**人为制造**高强度的认知训练。以下是几种可以在不依赖公司业务的情况下，自我进化的实操手段：

### 1. “影子格斗” (Shadow Boxing) —— 逆向重构

不要直接让 AI 生成最终代码，而是跟它玩“左右互搏”。

*   **Step 1：** 找一个经典的开源模块（比如 Redux 的核心逻辑，或者 Redis 的某个数据结构实现）。
*   **Step 2：** 给 AI 只有**需求描述**，让它生成实现代码。
*   **Step 3：** **（关键步骤）** 将 AI 生成的代码与**人类大师写的源码**进行逐行 Diff（比对）。
*   **Step 4：** 问自己：为什么大师在这里用了位运算而 AI 用了循环？为什么大师在这里多了一层看似无用的封装？
    *   *AI 的代码往往是“逻辑正确”的，而大师的代码往往包含着“对边界情况的防御”和“对未来扩展的预判”。*
    *   这种**Gap（差距）**，就是你即使不写代码也能习得的“品味”。

### 2. “预判练习” (Prediction Drills) —— 训练直觉

在阅读 AI 生成的代码之前，先强迫自己进行**“思维快照”**。

*   **场景**：你需要写一个带有重试机制的 HTTP 请求函数。
*   **练习**：在敲下 Prompt 之前，先在脑子里（或者纸上）列出这个函数必须处理的 **5 个 Edge Cases（边缘情况）**：
    1.  网络超时算重试吗？404 算重试吗？
    2.  重试间隔是固定的还是指数退避的？
    3.  最大重试次数到了之后抛出什么异常？
    4.  并发重试会不会打挂服务端？
*   **验证**：然后让 AI 生成代码。检查 AI 是否覆盖了你想到的这 5 点。
    *   如果 AI 漏了，你赢了——你发现了 AI 的盲区。
    *   如果 AI 想到了你没想到的（比如 Idempotency 幂等性），你学到了——这是知识盲区的补全。
*   **收益**：这种训练不消耗你的“打字时间”，只消耗你的“思考带宽”，效率是传统编程的十倍。

### 3. “故意找茬” (Bug Hunting) —— 调试能力优于编码能力

未来最昂贵的技能不是“写出功能”，而是“定位故障”。

*   **玩法**：利用 LLM 的能力，让它给你出题。
    > Prompt: "请生成一段 Python 代码，实现一个简单的 LRU Cache，但在其中埋下两个非常隐蔽的并发安全 Bug 和一个内存泄漏隐患。不要直接告诉我 Bug 在哪，让我来 Review。"
*   **过程**：你就像一个正在进行 Code Review 的 Tech Lead。你需要动用你所有的知识去找出这些地雷。
*   **复盘**：如果你找不出来，让 AI 揭晓答案，并解释为什么会产生这种 Bug。
    *   这种**“找错”**的训练，比你自己写代码更能锻炼对**系统健壮性**的理解。

---

## 三、 建立你的“代码博物馆”

以前我们通过“手熟”来积累经验，现在我们需要通过“眼高”来建立标准。
你需要有意识地收集两样东西：

### 1. The Good: 模式语言 (Pattern Language)
建立一个个人知识库（Obsidian/Notion），专门收集**“优雅的解决方式”**。
*   不是收集 `How to split string` 这种语法。
*   而是收集：**“当面对高并发读写锁竞争时，Go 标准库里的 `sync.Map` 是怎么设计的？”**
*   当你下次让 AI 生成类似代码时，你的 Prompt 会从 *“写个缓存”* 进化为 *“参考 sync.Map 的分段锁设计，为我写一个高并发缓存”*。这直接决定了 AI 输出的上限。

### 2. The Bad: 尸检报告 (Post-Mortem)
收集 AI 犯蠢的时刻。
*   AI 在处理时区转换时最容易犯什么错？
*   AI 在写递归时容易在哪里栈溢出？
*   AI 在 SQL 连表查询时容易忽略什么索引失效的场景？
*   **了解 AI 的弱点，是你保住饭碗的核心竞争力。** 你是 AI 的监工，你必须比工人更懂哪里容易偷工减料。

---

## 四、 结语：从“工匠”到“建筑师”

传统的初级程序员像是在**砌墙**，每一块砖都得自己搬，搬多了肌肉就发达了。
AI 时代的初级程序员必须像是在**玩乐高**，积木块是现成的（AI 生成），但你必须知道：
*   这个地基能不能承重？（原理）
*   这块积木和那块积木能不能卡紧？（接口契约）
*   整个造型美不美观？（系统架构与品味）

**不要因为不用砌墙而感到恐慌。你应该庆幸，你终于可以腾出手来，去思考整座大厦的设计图了。**
