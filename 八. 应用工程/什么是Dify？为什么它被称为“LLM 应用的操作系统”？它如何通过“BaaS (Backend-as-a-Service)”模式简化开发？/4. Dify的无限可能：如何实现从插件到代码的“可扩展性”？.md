# Dify 如何构建安全的插件生态与代码沙箱

如果说 DSL 决定了 LLM 应用的“下限”，那么**插件系统（Plugin System）**和**代码执行沙箱（Code Sandbox）**则决定了它的“上限”。

Dify 的扩展性设计，解决了一个核心矛盾：**如何在允许用户随意扩展功能的同时，保证系统的绝对安全与稳定？**

## 一、 插件系统：从“硬编码”到“标准化协议”

早期的 LangChain 应用往往通过 Python 函数直接调用外部 API（如 Google Search）。但在企业级平台中，这种方式是不可接受的，因为它破坏了系统的封闭性。

Dify 采用了**基于 OpenAPI 规范的声明式插件架构**。

### 1. 插件协议标准 (The Protocol)

如果你要设计插件系统，请放弃私有协议，拥抱标准。Dify 的插件定义包含两个核心文件：

- **`manifest.json`**: 插件的“身份证”。定义插件名称、图标、鉴权方式（Auth Type: API Key / OAuth2）。
- **`schema.yaml` (OpenAPI)**: 插件的“说明书”。描述 API 的 Endpoint、入参（Input Schema）和出参（Output Schema）。

**架构师视角**：

- **前端动态渲染**：前端 UI 不应硬编码任何插件的表单。前端应该读取 `schema.yaml`，根据参数类型（String, Number, Boolean）**动态生成配置表单**。
- **鉴权托管**：插件的 API Key 不应由插件代码管理，而应由平台统一托管。在发起请求时，平台自动将 Key 注入到 HTTP Header 中。

### 2. 插件运行模式 (Runtime Mode)

Dify 支持两种插件运行模式：

- **内置工具 (Built-in)**: Python 代码直接集成在 Worker 进程中。优点是速度快，缺点是如果工具崩溃会导致 Worker 重启。
- **API 工具 (API-based)**: 通过 HTTP 请求调用外部服务。这是最推荐的方式，实现了**控制面与数据面的解耦**。

## 二、 代码沙箱：在“笼子”里运行用户代码

Dify 允许用户在 Workflow 中添加 **"Code Node"**，编写 Python/Node.js 代码处理复杂的逻辑（如数据转换、正则提取）。

这带来了巨大的安全风险：**如果用户写了一段 `os.system('rm -rf /')` 怎么办？**

Dify 的解决方案是构建一个**多层隔离的沙箱环境 (Dify Sandbox)**。

### 1. 隔离技术选型 (Isolation Tech Stack)

- **Level 1: 容器化 (Docker)**

  - 沙箱服务本身运行在一个独立的 Docker 容器中。
  - 该容器没有挂载宿主机的任何敏感目录。

- **Level 2: 系统调用限制 (Seccomp)**

  - 这是最关键的一层。Dify 使用 **Seccomp (Secure Computing Mode)** 限制了代码执行进程的系统调用权限。
  - **禁止列表**：禁止 `fork`, `execve`（防止启动子进程），禁止 `socket`, `connect`（防止发起网络请求，除非显式白名单），禁止 `ptrace`（防止调试注入）。

- **Level 3: 资源配额 (Resource Quota)**
  - **CPU/Memory**: 使用 cgroups 限制 CPU 使用率和内存上限（如 128MB），防止死循环耗尽资源。
  - **Time**: 严格的超时控制（如 5 秒），超时直接 Kill 进程。

### 2. 通信架构设计

为了实现毫秒级的代码执行体验，不能为每个请求都 `docker run` 一个新容器（启动太慢）。

- **常驻进程 (Daemon Mode)**: Sandbox 容器内部运行着一个 Go 语言编写的 HTTP Server。
- **代码注入**: 主系统将用户的 Python 代码和输入变量封装成 JSON，POST 给 Sandbox Server。
- **临时文件**: Sandbox Server 将代码写入临时文件 `script.py`，然后通过 `exec` 调用 Python 解释器执行。
- **结果捕获**: 捕获 `stdout` 和 `stderr`，解析为 JSON 返回给主系统。

---

**给架构师的建议**：
扩展性设计的精髓在于**“信任边界”的划分**。

- **插件**是受信任的外部服务，通过标准 HTTP 协议交互。
- **用户代码**是绝对不可信的，必须将其关在“铜墙铁壁”的沙箱中。
- **不要试图在主进程中直接 `eval()` 用户代码**，这是安全架构的红线，绝对不能踩。
